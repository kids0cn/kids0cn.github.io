<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kids0cn.github.io</id>
    <title>kids&apos;s Blogger</title>
    <updated>2020-08-12T06:18:44.637Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kids0cn.github.io"/>
    <link rel="self" href="https://kids0cn.github.io/atom.xml"/>
    <subtitle>精耕细作</subtitle>
    <logo>https://kids0cn.github.io/images/avatar.png</logo>
    <icon>https://kids0cn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, kids&apos;s Blogger</rights>
    <entry>
        <title type="html"><![CDATA[【8-12】树莓派ubuntu升级Cmake]]></title>
        <id>https://kids0cn.github.io/post/8Hwn5sX2W/</id>
        <link href="https://kids0cn.github.io/post/8Hwn5sX2W/">
        </link>
        <updated>2020-08-12T06:03:02.000Z</updated>
        <content type="html"><![CDATA[<p>树莓派上运行的是Ubuntu Mate18.04的系统，自带的cmake版本是3.10.0，编译软件的时候要求cmake版本大于3.11.0。需要进行升级。<br>
<strong>注意</strong>网上的教程会让你卸载现在系统里cmake，就是执行如下的指令：</p>
<pre><code class="language-shell">sudo apt-get autoremove cmake
</code></pre>
<p><strong>千万不要这样操作</strong>，这样操作会顺便把所有cmake编译的程序都卸载掉，比如你的电脑里装好了ros系统，那么就全被干掉了。<br>
<strong>Cmake可以直接用新版本覆盖老版本，不需要卸载旧版本</strong></p>
<p>去Cmake的官网找到需要下载的版本：http://www.cmake.org/files/</p>
<pre><code class="language-shell">getconf LONG_BIT
</code></pre>
<p>检查下系统版本，32就是32位，64为64位<br>
我这里下载的是cmake 3.17.4</p>
<pre><code class="language-shell">wget https://cmake.org/files/v3.17/cmake-3.17.4.tar.gz
tar -zxvf cmake-3.17.4.tar.gz
</code></pre>
<p>进入解压的目录安装</p>
<pre><code class="language-shell">cd cmake-3.17.4
./configure
make
sudo make install
</code></pre>
<p>等待一段时间</p>
<p>检查版本</p>
<pre><code class="language-shell">cmake -version
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【8-11】树莓派上部署英特尔神经网络计算棒Intel NCS2]]></title>
        <id>https://kids0cn.github.io/post/XdBkG1tky/</id>
        <link href="https://kids0cn.github.io/post/XdBkG1tky/">
        </link>
        <updated>2020-08-11T12:05:08.000Z</updated>
        <content type="html"><![CDATA[<p>如果需要在树莓派上进行神经网络和计算机视觉的操作，仅仅依靠树莓派的性能，是远远不够的。而英特尔神经计算棒就可以用来进行CV的计算，从而在树莓派上部署人脸识别，手势识别之类的CV算法。<br>
<strong>注意：</strong></p>
<ul>
<li>树莓派必须使用树莓派官方系统Raspian。</li>
<li>树莓派上部署的工具包，仅能用来进行计算推理，其余功能需要用笔记本或者台式计算机。</li>
<li>官网的安装目录为 /opt/intel/openvino，也有博客建议安装到自己的本地目录，这里安装在~/intel/openvino</li>
</ul>
<h1 id="1驱动安装">1.驱动安装</h1>
<h2 id="1下载安装包">1.下载安装包</h2>
<pre><code class="language-shell">sudo mkdir -p ~/intel/openvino #建立一个文件夹
wget https://download.01.org/opencv/2020/openvinotoolkit/2020.4/\
  l_openvino_toolkit_runtime_raspbian_p_2020.4.287.tgz 
sudo tar -zxvf l_openvino_toolkit_runtime_raspbian_p_2020.4.287.tgz --strip 1 \ -C ~/intel/openvino
</code></pre>
<h2 id="2安装需要的工具">2.安装需要的工具</h2>
<pre><code class="language-shell">sudo apt install cmake
sudo apt-get install libgflags-dev
</code></pre>
<h2 id="3设置环境变量">3.设置环境变量</h2>
<p>直接将环境变量写入.bashrc文件</p>
<pre><code class="language-shell">echo &quot;source ~/intel/openvino/bin/setupvars.sh&quot; &gt;&gt; ~/.bashrc
source ~/.bashrc 
</code></pre>
<p>显示已经初始化完成<br>
[setupvars.sh] OpenVINO environment initialized</p>
<h2 id="4添加usb规则">4.添加USB规则</h2>
<p>不添加规则，树莓派无法访问设备</p>
<pre><code class="language-shell">sudo usermod -a -G users &quot;$(whoami)&quot;
</code></pre>
<p>退出重新登录</p>
<pre><code class="language-shell">sh ~/intel/openvino/install_dependencies/install_NCS_udev_rules.sh
</code></pre>
<h1 id="2运行测试">2.运行测试</h1>
<h2 id="1创建文件夹编译样例">1.创建文件夹编译样例</h2>
<pre><code class="language-shell">cd ~/intel/openvino/deployment_tools/inference_engine/samples/c
mkdir build
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=&quot;-march=armv7-a&quot;
 make -j4 object_detection_sample_ssd
</code></pre>
<h2 id="2下载权重文件">2.下载权重文件</h2>
<p>这里是官方自己的训练权重，以后用自己的模型，也需要提前训练好权重文件，并且转换为计算棒支持的格式<br>
现在的文件夹为：<br>
~/intel/openvino/deployment_tools/inference_engine/samples/c</p>
<pre><code class="language-shell">wget --no-check-certificate https://download.01.org/openvinotoolkit/2018_R4/open_model_zoo/face-detection-adas-0001/FP16/face-detection-adas-0001.bin

wget --no-check-certificate https://download.01.org/openvinotoolkit/2018_R4/open_model_zoo/face-detection-adas-0001/FP16/face-detection-adas-0001.xml
</code></pre>
<h2 id="3运行示例">3.运行示例</h2>
<pre><code class="language-shell">./armv7l/Release/object_detection_sample_ssd_c -m face-detection-adas-0001.xml -d MYRIAD -i  图片路径
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【2020-8-9】APM,PX4,GAZEBO,MAVLINK,MAVROS,ROS之间的关系以及科研设备选型]]></title>
        <id>https://kids0cn.github.io/post/HsNe95_fp/</id>
        <link href="https://kids0cn.github.io/post/HsNe95_fp/">
        </link>
        <updated>2020-08-09T14:21:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0概述">0.概述</h2>
<p>无人机自主飞行平台可以分为四个部分：动力平台，飞行控制器，机载电脑和模拟平台。</p>
<ul>
<li><strong>动力平台</strong>：负责执行飞行任务，包括螺旋桨、电机、机架等，用于科研的一般都是F380和F450的机架。</li>
<li><strong>飞行控制器</strong>：无人机使用的控制器取决于采用的固件：apm和pixhawk。用来调整无人机在空间中的位姿，给各个螺旋桨发送指令。</li>
<li><strong>机载电脑</strong>：作为上位机，通过MAVROS或者mavlink协议跟飞控通讯。可以搭载更多的机载设备诸如相机，各类传感器，通过机载电脑感知周围环境，做出更多智能化的工作。常见的机载电脑有x86平台的upboard，树莓派，英伟达的jetson。我们自己的实验平台机载电脑使用的是树莓派3b+，飞控是pixhawk，搭在了intel的realsense摄像头，深度摄像头，超声波和激光传感器。</li>
<li><strong>模拟平台</strong>：无人机作为航空设备，操作复杂，危险性高，就算是成熟的商业产品诸如大疆，也存在很多的炸鸡事故。所以，在进行实际飞行之前，一定要进行模拟操作，将程序修改好之后，才可以进行实机测试。</li>
</ul>
<h2 id="1apm和px4飞行控制器和">1.APM和PX4：飞行控制器和</h2>
<p>APM和PX4是自动驾驶和无人机领域最出名的两个固件。而因为历史原因，国内在两个固件的叫法上一直巨大的混淆。<br>
淘宝上比较常见的无人机飞控固件大体分为三类：APM，pixhawk2.4.8和pixhawk4。其中apm价格最便宜，px4价格最便宜。一般的无人机玩家，从预算考虑会购买apm，稍微预算充足的会购买pixhawk2.4.8的硬件。虽然从硬件配置和性能上，apm的硬件是远远不如pixhawk2.4.8的。<br>
但是一般用户购买的pixhawk产品，商家会提供一些pix_3.*.*之类的固件，这些固件实际上是乐迪公司修改过的apm的固件，商家提供的地面站也是apm公司mp地面站，而且是版本较老，汉化不全地面站。<br>
如果仅仅把无人机当做航拍设备，或者就是自己遥控玩一玩，这种刷着乐迪修改版固件的飞机是足够稳定的，还可以搭配乐迪自己的光流传感器和超声波避障模块，足够稳定，不管是室内还是室外。<br>
但是，如果需要用机载电脑进行自主控制，这一套就玩不转。<br>
如果需要使用px4的固件，则需要访问下面的地址，下载QGC地面站，刷pixhawk官方的固件。px4的固件最新的版本号也只有1.10.0。</p>
<p>APM网站：https://ardupilot.org/dev/index.html<br>
PX4网站：https://docs.px4.io/master/en/index.html</p>
<h2 id="2地面站missionplanmp和qgroundcontrolqgc">2.地面站：MissionPlan(MP)和QGroundControl(QGC)</h2>
<h3 id="21-apm">2.1 APM</h3>
<p>MP是APM公司推出的地面站软件，用来进行apm飞控的固件刷写，更新和监控飞行器状态，定点飞行的规划。国内常见的是不知道哪个大佬汉化的版本，汉化不全，版本很老，刷的固件也是乐迪公司修改过的固件。最新版的MP地面站和固件，可以通过访问上面的网站获取。</p>
<h3 id="22-px4">2.2 PX4</h3>
<p>QGroundControl（QGC）是px4官方出的地面站，用来进行px4固件的刷写，调参，监控飞行状态，定点飞行规划。一般国内玩家使用的较少，然而刷了PX4固件的机器，是没法跟APM地面站进行数据通信的，所以如果需要使用PX4的平台，就必须使用QGC，国内也有汉化版可以下载。</p>
<h2 id="2mavlink和mavros通信协议">2.MAVLINK和MAVROS：通信协议</h2>
<p>MAV协议是上位机和飞控通信的通信协议，MAVROS是基于ROS系统的MAV协议，可以和ROS系统相结合。</p>
<h2 id="3gazebo仿真软件">3.GAZEBO仿真软件</h2>
<p>Gazebo是ROS系统自带的仿真平台，可以通过mavros通信协议，将飞控的操作数据反馈到仿真平台。进行无人机的仿真操作。</p>
<h2 id="4ros机器人操作系统">4.ROS：机器人操作系统</h2>
<p>国际最通用的机器人操作系统，将不同硬件的操作进行封装，通过简单的话题发布和订阅，可以让算法开发者不必考虑不同的硬件平台，以及各种硬件之间的配合，仅需要用自己的熟悉的Python或者C++语言编写算法，ROS负责联通算法实施和硬件驱动和模拟仿真。</p>
<h2 id="5自主无人飞行平台选型">5.自主无人飞行平台选型</h2>
<p>PX4官方出了整套解决方案px4-vision价格大概在16000元，国内有阿木实验室在做整机销售，树莓派版本也在12000多左右。我们自己做的性能相近或者超越的整机平台价格在6000以下。有需要的也可以联系我们。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【2020-8-8】树莓派+Ubuntu18.04编译Dji Guidance ROS]]></title>
        <id>https://kids0cn.github.io/post/TGQMWjI7t/</id>
        <link href="https://kids0cn.github.io/post/TGQMWjI7t/">
        </link>
        <updated>2020-08-08T11:16:06.000Z</updated>
        <content type="html"><![CDATA[<p>实验室还有一批大疆的M100和配套的Guidance，但是一直没有玩起来，大疆官方也早就抛弃了这个平台，不再提供技术支持。<br>
今天在树莓派上编译Intel Realsense的固件的时候，看到大疆之前还提供了适用于16.04的guidance_ros的包，就试着编译了一下。结果正常，只需要修改一些地方。明天用到机器上试试。<br>
由于dji在16年发布，17年基本上就被大疆抛弃了，所以只能识别出openc2。所以修改掉源文件的CMakelist。</p>
<pre><code class="language-c">cmake_minimum_required(VERSION 2.8.3)
project(guidance)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  cv_bridge
  std_msgs
  sensor_msgs
  geometry_msgs
)
#####
find_package(OpenCV 2 REQUIRED core highgui)
#####
catkin_package(
)

include_directories(
  ${OpenCV_INCLUDE_DIRS}
  ${catkin_INCLUDE_DIRS}
  include
)

message(&quot;System is: &quot; ${CMAKE_SYSTEM_PROCESSOR})
if (${CMAKE_SYSTEM_NAME} MATCHES &quot;Linux&quot;)
  if (CMAKE_SIZEOF_VOID_P EQUAL 4)
    message(&quot;-- 32bit detected&quot;)
    link_directories(lib/x86)
  elseif (CMAKE_SIZEOF_VOID_P EQUAL 8)
    message(&quot;-- 64bit detected&quot;)
    link_directories(lib/x64)
  endif ()
else()
  message(&quot;-- Non-linux platform detected but sorry we do not support :D&quot;)
endif ()

if (${CMAKE_SYSTEM_PROCESSOR} MATCHES &quot;armv7l&quot; )
  message(&quot;-- &quot; ${CMAKE_SYSTEM_PROCESSOR} &quot; detected&quot;)
  link_directories(lib/XU3)
else ()
endif ()

##cyril add the following
message(STATUS &quot;OpenCV library status:&quot;)
message(STATUS &quot;    version: ${OpenCV_VERSION}&quot;)
message(STATUS &quot;    libraries: ${OpenCV_LIBS}&quot;)
message(STATUS &quot;    include path: ${OpenCV_INCLUDE_DIRS}&quot;)

link_libraries(
  ${OpenCV_LIBS}
  ${catkin_LIBRARIES}
  DJI_guidance

  usb-1.0
  yaml-cpp)

add_executable(guidanceNode
  src/GuidanceNode.cpp
  src/DJI_utility.cpp)

add_executable(guidanceNodeTest
  src/GuidanceNodeTest.cpp)

add_executable(guidanceNodeCalibration
  src/GuidanceNodeCalibration.cpp
  src/DJI_utility.cpp)
</code></pre>
<p>修改标注出来的地方，去掉2就行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【20-8-7】树莓派上部署英特尔深度相机IntelRealsense T265]]></title>
        <id>https://kids0cn.github.io/post/qZKoxBQGg/</id>
        <link href="https://kids0cn.github.io/post/qZKoxBQGg/">
        </link>
        <updated>2020-08-07T11:55:39.000Z</updated>
        <content type="html"><![CDATA[<p>最近在搭建无人机的自主飞行平台，无GPS的情况下室内定位的方案除了光流，最好的就是配合intel的realsense系列的摄像头。尤其是T265本身带IMU，可以直接给飞控输出位姿信息，不管是APM固件还是PX4固件，在ROS和MAVROS的帮助下，都可以直接获取T265的信息。<br>
自主飞行平台的板载电脑是树莓派3b+，运行ubuntu mate 18.04的系统和ROS Melodic，理论上可以随时更换为性能更强劲的英伟达Jetson系列系统，或者intel upboard系列。<br>
ROS的安装，在其他的文章中已经讲过了。本文只涉及部署Intel的T265相机。分为两个部分，SDK的安装和ROS节点的安装。前提是ROS系统已经被部署在树莓派上。</p>
<h2 id="0-预操作扩大swap分区">0. 预操作：扩大Swap分区</h2>
<p>Ubuntu mate默认的Swap分区太小，编译时会直接卡死，并且不会报错，所以首先要扩大swap分区。另外，编译操作会让树莓派温度升高的很厉害，需要安装好散热风扇。<br>
查看当前的交换空间大小，我的默认是100M</p>
<pre><code class="language-shell">free -m 
</code></pre>
<p><strong>1.建立交换空间文件</strong><br>
随便在哪里都行，放到碰不到的地方，防治误删除</p>
<pre><code class="language-shell">cd /opt/
sudo mkdir swap_temp #名字任意起
cd swap_temp
sudo touch swap

</code></pre>
<p><strong>2.设置交换文件的大小</strong></p>
<pre><code class="language-shell">sudo dd if=/dev/zero of=/opt/swap_temp/swap bs=1024 count=3048000  # 我这里设置的是3G
</code></pre>
<p>等一会儿，结束时才会有回显，我的写入速度是20M每秒，3G需要2分钟左右<br>
结束后返回：</p>
<pre><code>3048000+0 records in
3048000+0 records out
2097152000 bytes (2.9 GB, 3.0 GiB) copied, 242.095 s, 18.7 MB/s
</code></pre>
<p><strong>3.设置为交换空间</strong></p>
<pre><code class="language-shell">sudo mkswap /opt/swap_temp/swap
</code></pre>
<p><strong>4.启用交换空间</strong></p>
<pre><code class="language-shell">sudo swapon /opt/swap_temp/sawp
</code></pre>
<p>现在已经可以使用了，通过free -m查看</p>
<p><strong>5.写入分区</strong></p>
<pre><code class="language-shell">sudo vim /etc/fstab
文件最后加入
/opt/swap_temp/sawp /swap swap defaults 0 0
</code></pre>
<h2 id="1intel-realsense-sdk的安装">1.Intel Realsense SDK的安装</h2>
<p><strong>1.安装依赖包</strong></p>
<pre><code class="language-shell">sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get dist-upgrade
sudo apt-get install git cmake libssl-dev libusb-1.0-0-dev pkg-config libgtk-3-dev
sudo apt-get install libglfw3-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
<p>第二行的是核心依赖，必装。第三行是3D相关的依赖，如果不打算使用realsense-viewer，可以不装，树莓派性能有限，安装SDK的目的是为了安装好驱动，不需要执行太多本机操作，建议内存卡小的不用装了。</p>
<p><strong>3.下载Realsense SDK</strong></p>
<pre><code class="language-shell">git clone https://github.com/IntelRealSense/librealsense.git
</code></pre>
<p><strong>4.编译准备</strong></p>
<pre><code class="language-shell">cd librealsense
mkdir build &amp;&amp; cd build
cmake ../ -DCMAKE_BUILD_TYPE=Release -DBUILD_EXAMPLES=true \
-DFORCE_RSUSB_BACKEND=ON -DBUILD_WITH_TM2=false -DIMPORT_DEPTH_CAM_FW=false
</code></pre>
<p><strong>-DFORCE_RSUSB_BACKEND=ON 必选，强制LIBUVC后端，否则你要自己给内核打补丁。</strong><br>
<strong>5.编译</strong></p>
<pre><code class="language-shell">sudo make uninstall &amp;&amp; make clean &amp;&amp; make -j2 &amp;&amp; sudo make install -2
</code></pre>
<p><img src="https://kids0cn.github.io/post-images/1596802908724.png" alt="" loading="lazy"><br>
我自己的3B+需要编译三小时左右。中间交换空间最大占用为1.6G。</p>
<p><strong>6.设置udev规则</strong></p>
<pre><code class="language-shell">sudo ./scripts/setup_udev_rules.sh
</code></pre>
<p>主要是为了识别设备，最重要的也就是这里<br>
<strong>7.测试</strong></p>
<pre><code class="language-text">realsense-viewer
</code></pre>
<p>我的机载电脑没有开图形界面，一般都是VNC连接上去。</p>
<h2 id="2-编译ros驱动">2. 编译ROS驱动</h2>
<p>目的是为了让ROS节点可以订阅T265发回的IMU信息。<br>
英特尔官方发布了两种安装方式，1是通过apt的方式安装二进制文件，2是通过源码编译。但是前提是系统里已经安装好了对应的ROS系统，我的是18.04+Melodic</p>
<h3 id="21-apt-get-安装">2.1 APT-Get 安装</h3>
<pre><code class="language-shell">export ROS_VER=melodic
</code></pre>
<p>安装</p>
<pre><code class="language-shell">sudo apt-get install ros-$ROS_VER-realsense2-camera
</code></pre>
<p>用于3D显示的库</p>
<pre><code>sudo apt-get install ros-$ROS_VER-realsense2-description
</code></pre>
<p>注意：</p>
<ul>
<li>这种方法安装的librealsense2总是落后于最新发布的版本</li>
</ul>
<h3 id="22-源码编译">2.2 源码编译</h3>
<h5 id="1创建工作目录">1.创建工作目录</h5>
<p>工作目录的名字不一定要是catkin_ws</p>
<pre><code class="language-shell">mkdir -p ~/catkin_ws/src
cd ~/catkin_ws/src/
</code></pre>
<h5 id="2克隆源码">2.克隆源码</h5>
<pre><code class="language-shell">git clone https://github.com/IntelRealSense/realsense-ros.git
cd realsense-ros/
git checkout `git tag | sort -V | grep -P &quot;^\d+\.\d+\.\d+&quot; | tail -1`
cd ..
</code></pre>
<h5 id="3编译">3.编译</h5>
<pre><code class="language-shell">catkin_init_workspace
cd ..
catkin_make clean
catkin_make -DCATKIN_ENABLE_TESTING=False -DCMAKE_BUILD_TYPE=Release
catkin_make install
echo &quot;source ~/catkin_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<h3 id="3使用">3.使用</h3>
<p>启动节点</p>
<pre><code class="language-shell">roslaunch realsense2_camera rs_camera.launch
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[玩转VIM]]></title>
        <id>https://kids0cn.github.io/post/sfK70jTHc/</id>
        <link href="https://kids0cn.github.io/post/sfK70jTHc/">
        </link>
        <updated>2020-07-26T12:29:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1vim编辑">1.Vim编辑</h2>
<h3 id="11-vim模式和基本操作">1.1 Vim模式和基本操作</h3>
<h4 id="111-command模式">1.1.1 Command模式</h4>
<p>（1）分屏：<br>
<strong>:vs(vertical split)</strong> 垂直分屏<br>
<strong>:sp(split)</strong> 水平分屏<br>
（2）全局替换<br>
<strong>:%s/foo/bar/g</strong></p>
<h4 id="112-normal模式">1.1.2 Normal模式</h4>
<p>快速切换到Normal模式:<strong>&lt;c-[&gt;</strong>；<strong><c-c></strong>（这个不好，有时会中断插件）</p>
<h4 id="113-insert模式">1.1.3 Insert模式</h4>
<p>（1）小写指令:<br>
<strong>i(insert)</strong>:光标前插入;<strong>a(append)</strong>:光标后插入;<strong>o(open a newline)</strong>:新行插入<br>
（3）大写指令<br>
<strong>I</strong>:行前插入；<strong>A</strong>:行尾插入；<strong>O</strong>：往上开新行<br>
（3）编辑模式快速纠错<br>
均是linux命令行通用快捷键，可以在命令行输入命令时使用<br>
<strong><c-h></strong>:删除上一个字符；<strong><c-w></strong>:删除上一个单词;<strong><c-u></strong>:删除当前行<br>
注意，这些快捷操作是命令行提供的功能，用<c-u>无法恢复</p>
<h4 id="114-visual模式">1.1.4 Visual模式</h4>
<p><strong>v</strong>:行选择 ； <strong><c-v></strong>:块选择</p>
<h3 id="12-vim快速移动">1.2 Vim快速移动</h3>
<h4 id="121基本移动">1.2.1基本移动</h4>
<p>(1)h,j,k,l移动<br>
(2)单词间移动<br>
<strong>w/W</strong>：下一个单词开头；<strong>b/B</strong>：上一个单词开头;<strong>e/E</strong>：下一个单词的末尾</p>
<h4 id="122行间搜索移动">1.2.2行间搜索移动</h4>
<p><strong>f(find){char}</strong>：移动到char上，<strong>,</strong>:上一个、<strong>;</strong>:下一个<br>
F反过来搜索</p>
<h4 id="123水平和搜索移动">1.2.3水平和搜索移动</h4>
<p>（1）水平：<br>
<strong>0</strong>:行首第一个字符；<strong>^</strong>:行首第一个非空白字符<br>
<strong>$</strong>:行尾最后一个字符；<strong>g_</strong>:行尾最后一个非空白字符<br>
（2)垂直：<br>
<strong>()</strong>:句子间；<strong>{}</strong>:段落间</p>
<h4 id="124页面间移动">1.2.4页面间移动</h4>
<p><strong>gg</strong>:文件开头;<strong>G</strong>:文件结尾<br>
<strong><c-o></strong>:快速返回<br>
<strong>H/M/L</strong>:屏幕的开头(Head)/中间(Middle)/结尾(Low)<br>
<strong><c-u>/<c-f></strong>:upward/forward 山下翻页<br>
<strong>zz</strong>:当前行移动到屏幕中间</p>
<h3 id="13-vim快速增删改查">1.3 vim快速增删改查</h3>
<h4 id="131-增">1.3.1 增</h4>
<p>进入insert模式</p>
<h4 id="132-删">1.3.2 删</h4>
<p><strong>x</strong>:删除一个字符；<strong>2x</strong>:删除两个字符<br>
<strong>dw</strong>:删除一个单词;<strong>dt</strong>:删除直到(dt &quot;:删除直到&quot;字符);<strong>d0</strong>:删除到行首; <strong>d$</strong> 删除到行尾;<strong>2dd</strong>:删除2行</p>
<h5 id="133-改">1.3.3 改</h5>
<p><strong>r(replace)</strong>:修改一个字符；<strong>c(change)</strong>:修改一个字符;<strong>s(substitute)</strong>:修改一个字符并进入insert模式<br>
<strong>R</strong>:不停替换；<strong>S</strong>:删除整行并进入insert模式</p>
<h4 id="134-查">1.3.4 查</h4>
<p><strong>/</strong>:前向搜索 <strong>?</strong>:反向搜索 ； <strong>n/N</strong> 下一个/上一个匹配</p>
<h3 id="14-vim进行搜索替换">1.4 vim进行搜索替换</h3>
<p>substitute命令允许我们进行搜索替换，并支持正则表达式<br>
<strong>:[range]s(ubstitute)/{parttern}/{string}/[flag]</strong><br>
range(范围)：10，20（从第10行到第20行）；%（全部替换）<br>
flag(标志)：</p>
<ul>
<li>g(global):全局替换</li>
<li>c(confirm):替换确认</li>
<li>n(number):不替换，返回匹配次数</li>
</ul>
<h3 id="15-vim多文件操作">1.5 vim多文件操作</h3>
<ul>
<li><strong>Buffer</strong>:打开文件的内存缓冲区</li>
<li><strong>Window</strong>:buffer可视化的分割区域</li>
<li><strong>Tab</strong>:组织window为一个工作区</li>
</ul>
<h4 id="151-buffer切换">1.5.1 Buffer切换</h4>
<p><strong>:ls</strong> 列出缓冲区 |  <strong>:b n</strong> 跳转到n<br>
<strong>:bpre | bnext | bfisrt | blast | :b buf_name</strong></p>
<h4 id="152-window窗口">1.5.2 window窗口</h4>
<p>**:sp/<c-w>s **:水平分割   <strong>:vs/<c-w>v</strong> :垂直分割<br>
**<c-w>w **:循环切换   <strong><c-w>h/j/k/l</strong>     **<c-w>L <strong>：左右互换 ** <c-w>=</strong> :等分</p>
<h4 id="153-tab">1.5.3 tab</h4>
<p>用的不多</p>
<h3 id="16-vim的text-object文本对象">1.6 vim的text object（文本对象）</h3>
<p>vim中的文本对象指单词、句子、段落，有了文本对象，可以通过指令直接操作对应的文对对象进行操作。<br>
<strong>[number]<command>[text object]</strong><br>
例子：<br>
单词：w  <strong>2dw</strong> ; 句子: s <strong>2ds</strong>;  段落：p  <strong>2dp</strong>  #好像后面两个都没用<br>
<strong>i (inner):</strong> di“ (删除不包括&quot;)<br>
**a (around): **  da&quot;(删除包括&quot;)</p>
<h3 id="17-vim复制粘贴与寄存器的使用">1.7 vim复制粘贴与寄存器的使用</h3>
<h4 id="171-normal模式的复制粘贴">1.7.1 Normal模式的复制粘贴</h4>
<p><strong>y(yank)  复制   yy 复制一行</strong> ； <strong>p(paste) 粘贴</strong></p>
<h4 id="172-insert模式避免乱码">1.7.2 Insert模式避免乱码</h4>
<p>如果开启了vim的autoindent模式，粘贴时格式会乱掉.<br>
<strong>:set paste   临时关闭autoindent 进入粘贴模式</strong><br>
<strong>:set nopaste</strong></p>
<h4 id="173-寄存器的使用">1.7.3 寄存器的使用</h4>
<p>每次使用d,y命令时，会把内容放到一个无名寄存器，也可以在操作时指定对应的寄存器，以操作寄存器数据。<br>
<strong>ayw :</strong> 复制一个单词到寄存器a ;  ** bdd ：**删除一行到寄存器b</p>
<h4 id="174-使用系统剪贴板">1.7.4 使用系统剪贴板</h4>
<p>在操作前加上&quot;+&quot;号，如&quot;+yw&quot;<br>
<strong>:set clipboard=unnamed</strong></p>
<h4 id="175-vim宏功能macro">1.7.5 Vim宏功能(macro)</h4>
<p>宏为一系列命令的合集，vim使用q录制，q结束录制,q{register}指定寄存器，@{register}回放</p>
<h4 id="176-vim补全功能">1.7.6 Vim补全功能</h4>
<h4 id="177-vim换配色">1.7.7 Vim换配色</h4>
<p>把配色文件xx.vim放到&quot;～/.vim/colors&quot;下面，vimrc里面写入“colorscheme 要使用的配色名字”</p>
<h2 id="2vim配置">2.Vim配置</h2>
<h3 id="21-vim常用配置">2.1 Vim常用配置</h3>
<pre><code class="language-shell">&quot;设置编码，中文不乱码&quot;
&quot;encoding选项用于缓存的文本、寄存器、Vim 脚本文件等；&quot;
&quot;fileencoding选项是Vim写入文件时采用的编码类型；&quot;
&quot;termencoding选项表示输出到终端时采用的编码类型&quot;
set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8 

&quot;显示行号&quot;
set nu

&quot;突出显示当前行&quot;
&quot;set cursorline
set cul

&quot;突出显示当前列&quot;
&quot;set cursorcolumn
set cuc

&quot;显示括号匹配&quot;
set showmatch

&quot;设置缩进&quot;
&quot;设在tab的长度
set tabstop=4
&quot;设置自动缩进长度
set shiftwidth=4
&quot;设置自动继承前一行的缩进
set autoindent

&quot;设置粘贴模式，保证粘贴时格式不乱
set paste

&quot;显示空格和tab键
set listchars=tab:&gt;-,trail:-

&quot;总是显示状态栏和当前光标位置
set laststatus=2
set ruler

&quot;打开文件类型检测
filetype plugin indent on

&quot;设置语法高亮
syntax on

“vim-plug插件配置部分
call plug#begin(&quot;~/.vim/plugged&quot;)
Plug 'junegunn/vim-easy-align'
Plug 'vim-airline/vim-airline'
Plug 'Shougo/neocomplete.vim'
Plug 'kien/rainbow_parentheses.vim'
Plug 'scrooloose/syntastic'
Plug 'vim-airline/vim-airline-themes'
Plug 'mhinz/vim-startify'
call plug#end()
</code></pre>
<h3 id="22-vim中的映射">2.2 Vim中的映射</h3>
<h2 id="3vim-plug配置">3.VIm-Plug配置</h2>
<p>vim-plug是一款非常轻量又高效的vim插件管理工具。它支持全异步、多线程并行安装插件，支持git分支、标签等，可以对插件进行回滚更新、还支持按需加载插件(On-demand loading)，可以指定对特定文件类型加载对应vim插件，大大加快了vim启动时间。</p>
<h3 id="1安装">1.安装</h3>
<p>项目官方地址：https://github.com/junegunn/vim-plug<br>
vim-plug使用github进行托管和维护，只需要下载对应的 plug.vim 文件并保存到 autoload 目录即可完成安装。</p>
<h4 id="11安装方式一">1.1安装方式一</h4>
<pre><code class="language-shell">$mkdir ~/.vim/autoload/
$cd ~/.vim/autoload/
$wget https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
</code></pre>
<h4 id="2安装方式二">2.安装方式二</h4>
<p>利用curl工具自动完成上述过程</p>
<pre><code class="language-shell">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
</code></pre>
<h3 id="2配置">2.配置</h3>
<p>在vim配置文件 ~/.vimrc 增加以 call plug#begin(PLUGIN_DIRECTORY) 开始，并以 plug#end() 结束的配置段即可。<br>
下面是一个典型的vim-plug的配置实例，使用了多种vim-plug相关的配置形式。</p>
<pre><code class="language-shell">call plug#begin('~/.vim/plugged')
# 使用缩写形式指定了项目的github地址
Plug 'junegunn/vim-easy-align'
#使用全地址形式指定github地址
Plug 'https://github.com/junegunn/vim-github-dashboard.git'
#用&quot;|&quot;符号把两个插件写在一行中
Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'
#使用 按需加载，表明只有在 NERDTreeToggle 命令被调用时, 对应的插件才会被加载；
Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }
#使用 按需加载，表明只有编辑 clojure 类型的文件时该插件才会被打开；
Plug 'tpope/vim-fireplace', { 'for': 'clojure' }
#指定使用YCM-Generator插件的stable分支
Plug 'rdnetto/YCM-Generator', { 'branch': 'stable' }
#指定插件所用的git标签，rtp描述了包含im插件的子目录
Plug 'nsf/gocode', { 'tag': 'v.20150303', 'rtp': 'vim' }
#用 dir 选项单独指定了该插件存放的目录，do选项用于 Post-update hook，指定在安装或者更新完插件后所需要执行的额外操作；
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
#表示不用github托管的本地vim插件
Plug '~/my-prototype-plugin'
call plug#end()
</code></pre>
<h3 id="3使用">3.使用</h3>
<p>在vim里，使用如下命令进行插件的安装和使用</p>
<h4 id="31-状态检查">3.1 状态检查</h4>
<pre><code class="language-shell">:PlugStatus
</code></pre>
<h4 id="32-安装插件">3.2 安装插件</h4>
<pre><code class="language-shell">:PlugInstall #安装配置文件中指定的所有插件
:PlugInstall [name][#thread] #指定安装的插件和使用线程
</code></pre>
<h4 id="33-更新插件">3.3 更新插件</h4>
<pre><code class="language-shell">:PlugUpdate
</code></pre>
<h4 id="34-卸载插件">3.4 卸载插件</h4>
<p>卸载在vimrc中删除或者注释掉的插件</p>
<pre><code class="language-shell">:PlugClean
</code></pre>
<h4 id="35-升级vim-plus本身">3.5 升级vim plus本身</h4>
<pre><code class="language-shell">:PlugUpgrade
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://kids0cn.github.io/post/hello-gridea/</id>
        <link href="https://kids0cn.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>